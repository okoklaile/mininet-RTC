#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import sys
import os
import subprocess
import traceback
import json

sys.path.append(os.getcwd())

import cmdinfer


def main():
    # Get the absolute path of the binary
    script_dir = os.path.dirname(os.path.abspath(__file__))
    binary_path = os.path.join(script_dir, "peerconnection_serverless.origin")
    
    # 确保 LD_LIBRARY_PATH 包含 lib 目录
    lib_dir = os.path.join(os.path.dirname(script_dir), 'lib')
    if 'LD_LIBRARY_PATH' in os.environ:
        os.environ['LD_LIBRARY_PATH'] = lib_dir + ':' + os.environ['LD_LIBRARY_PATH']
    else:
        os.environ['LD_LIBRARY_PATH'] = lib_dir
    
    # v1最原始版本，v2添加了生成块视频，v3更改了上限rate,v4更改了日志结构，
    # v5增加了丢包率，网络延迟等的日志统计，
    # v6增加了日志内容看limitation在哪,v7调整了最大kbps的限制更合理了.
    # v8fake帧生成，v9去除挂起限制,v10增加了bwe的返回信息
    app = subprocess.Popen(
        [binary_path] + sys.argv[1:],
        bufsize=0,  # 使用无缓冲模式（二进制模式下不支持行缓冲）
        stdin=subprocess.PIPE,
        stdout=subprocess.PIPE,
        stderr=subprocess.STDOUT)
    try:
        cmdinfer.main(app.stdout, app.stdin)
        app.wait()
    except:
        app.terminate()
        app.wait()
        error_message = traceback.format_exc()
        error_message = "\n{}".format(error_message)
        sys.stderr.write(error_message)
        if len(sys.argv[1:]) == 0:
            return
        config_file = sys.argv[1]
        config_file = json.load(open(config_file, "r"))
        if "logging" not in config_file:
            return
        if "enabled" not in config_file["logging"] or not config_file["logging"]["enabled"]:
            return
        with open(config_file["logging"]["log_output_path"], "a") as log_file:
            log_file.write(error_message)


if __name__ == "__main__":
    main()